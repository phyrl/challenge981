<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ÁâõÈ†ìÁöÑËÄÉÈ©ó - ÂãªÂä†ÈÄüÂÖ¨ÂºèÁâà</title>
<style>
    /* Reset and Liquid Fullscreen Setup */
    body { margin: 0; padding: 0; background-color: #2c3e50; display: flex; justify-content: center; align-items: center; height: 100vh; height: 100dvh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; color: white; }
    
    /* Container strictly follows window size for 100% fill */
    #gameContainer { position: relative; width: 100vw; height: 100vh; background-color: #34495e; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    
    /* Top UI */
    #ui { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; font-size: clamp(16px, 4vw, 24px); font-weight: bold; pointer-events: none; z-index: 2; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
    
    /* Current Equation Display */
    #equationDisplay { position: absolute; top: 60px; left: 0; right: 0; text-align: center; font-size: clamp(20px, 5vw, 36px); font-weight: bold; color: #f1c40f; pointer-events: none; z-index: 2; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); background: rgba(0,0,0,0.4); padding: 10px 0; letter-spacing: 5px;}
    
    #powerUpMsg { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); font-size: clamp(18px, 5vw, 24px); font-weight: bold; color: #2ecc71; text-shadow: 0 0 10px #27ae60, 2px 2px 4px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 2; }
    
    /* Mobile controls */
    #controls { position: absolute; bottom: 30px; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0 10vw; z-index: 5; pointer-events: none; }
    .control-btn { width: min(18vw, 80px); height: min(18vw, 80px); border-radius: 50%; border: 3px solid rgba(255,255,255,0.6); background: rgba(0, 0, 0, 0.4); color: white; font-size: clamp(20px, 6vw, 36px); display: flex; justify-content: center; align-items: center; pointer-events: auto; cursor: pointer; user-select: none; transition: background 0.1s; }
    .control-btn:active { background: rgba(0, 0, 0, 0.7); transform: scale(0.95); }
    
    /* Overlay */
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; overflow-y: auto; padding: 20px; box-sizing: border-box;}
    #overlay h1 { font-size: clamp(24px, 6vw, 40px); margin-bottom: 5px; color: #e74c3c; /* ËòãÊûúÁ¥Ö */ text-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
    #finalScore { font-size: clamp(18px, 4vw, 24px); margin-bottom: 10px; color: #ecf0f1; }
    
    #playerName { font-size: clamp(16px, 4vw, 22px); padding: 10px; text-align: center; border-radius: 8px; border: 2px solid #fff; outline: none; text-transform: uppercase; width: 80%; max-width: 250px; margin-bottom: 15px; font-weight: bold; background: rgba(255,255,255,0.9); color: #2c3e50;}
    
    #difficultyUI { margin-bottom: 15px; font-size: clamp(14px, 3.5vw, 18px); background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;}
    #difficultyUI label { cursor: pointer; display: flex; align-items: center; }
    
    /* Leaderboard */
    #leaderboard { background: rgba(255,255,255,0.1); padding: 15px 20px; border-radius: 10px; margin-bottom: 15px; text-align: left; width: 90%; max-width: 400px; }
    #leaderboard h3 { margin: 0 0 10px 0; color: #f1c40f; text-align: center; font-size: clamp(18px, 4vw, 24px);}
    #leaderboard ol { margin: 0; padding-left: 25px; font-size: clamp(14px, 4vw, 18px); line-height: 1.5;}
    .diff-badge { font-size: 12px; background: #e74c3c; padding: 2px 6px; border-radius: 4px; margin-left: 5px; color: white;}
    .name-badge { font-weight: bold; color: #3498db; margin-right: 10px; }
    
    button.start { padding: 12px 40px; font-size: clamp(18px, 5vw, 24px); cursor: pointer; border: none; border-radius: 50px; background-color: #e74c3c; color: white; font-weight: bold; box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4); transition: 0.2s; margin-top: 10px;}
    button.start:hover { background-color: #c0392b; transform: scale(1.05); }
    button:disabled { background-color: #7f8c8d; cursor: not-allowed; transform: none;}
    
    .hidden { display: none !important; }
</style>
</head>
<body>

<div id="gameContainer">
    <div id="ui">
        <div id="timeDisplay">ÊôÇÈñì: 30.00s</div>
        <div id="scoreDisplay">ÂÆåÊàê: 0/4</div>
    </div>
    <div id="equationDisplay">_</div>
    <div id="powerUpMsg">‚≠ê‚≠ê ÂÖ¨ÂºèË≠∑Áõæ ‚≠ê‚≠ê</div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="controls"><div class="control-btn" id="btnLeft">‚óÄ</div><div class="control-btn" id="btnRight">‚ñ∂</div></div>
    
    <div id="overlay">
        <h1 id="gameOverTitle">üçé ÁâõÈ†ìÁöÑËÄÉÈ©ó üçé<br>ÂãªÂä†ÈÄüÂÖ¨ÂºèÁâà</h1>
        <div id="finalScore" class="hidden">ÁµêÊûú</div>
        
        <input type="text" id="playerName" maxlength="10" placeholder="ÂÖ•Âêç (ÊúÄÂ§ö10ÂÄãËã±ÊñáÂ≠ó)" autocomplete="off">
        
        <div id="leaderboard">
            <h3>‚òÅÔ∏è Èõ≤Á´ØÂ≠∏Èú∏Ê¶ú (Top 5)</h3>
            <ol id="scoreList"><li>ÈÄ£Á∑ö‰∏≠...</li></ol>
        </div>

        <div id="difficultyUI">
            <label><input type="radio" name="diff" value="easy"> Èõ£Â∫¶ 0</label>
            <label><input type="radio" name="diff" value="normal" checked> Èõ£Â∫¶ 9.81</label>
            <label><input type="radio" name="diff" value="hard"> Èõ£Â∫¶ 19.62</label>
            <label><input type="radio" name="diff" value="very_hard"> Èõ£Â∫¶ 29.43</label>
        </div>

        <button class="start" id="startBtn">ÈñãÂßãÊåëÊà∞</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";

    // üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥
    // Ë´ãÂ∞áÂë¢ÊÆµÊèõËøîÂÅö‰Ω†Ëá™Â∑±ÂòÖ Firebase Config üî¥
    // üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥ üî¥
    const firebaseConfig = {
      apiKey: "AIzaSyDoHHh-8Gm5tt_uWF4IPGIGfOTNYnAgHr4",
      authDomain: "physicsgame-rl.firebaseapp.com",
      projectId: "physicsgame-rl",
      storageBucket: "physicsgame-rl.firebasestorage.app",
      messagingSenderId: "68402923149",
      appId: "1:68402923149:web:0bb2be531b9e971a6544c4"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    const timeDisplay = document.getElementById('timeDisplay'); const scoreDisplay = document.getElementById('scoreDisplay');
    const equationDisplay = document.getElementById('equationDisplay'); const powerUpMsg = document.getElementById('powerUpMsg');
    const overlay = document.getElementById('overlay'); const startBtn = document.getElementById('startBtn');
    const gameOverTitle = document.getElementById('gameOverTitle'); const finalScore = document.getElementById('finalScore');
    const scoreList = document.getElementById('scoreList'); const difficultyRadios = document.getElementsByName('diff');
    const playerNameInput = document.getElementById('playerName');

    // Handle canvas resize for liquid fullscreen
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    playerNameInput.addEventListener('input', function() { this.value = this.value.replace(/[^A-Za-z]/g, '').toUpperCase(); });

    // Physics Formulas Definitions
    const formulas = [
        ['v', '=', 'u', '+', 'a', 't'],
        ['s', '=', '¬Ω', '(', 'u', '+', 'v', ')', 't'],
        ['s', '=', 'u', 't', '+', '¬Ω', 'a', 't', '¬≤'],
        ['v', '¬≤', '=', 'u', '¬≤', '+', '2', 'a', 's']
    ];
    
    // Valid symbols pool
    const allValidSymbols = ['s', 'u', 'v', 'a', 't', '=', '+', '(', ')', '¬≤', '¬Ω', '2'];
    const trapSymbols = ['4', '-', '¬º', '‚àö'];

    // Game State
    let isPlaying = false; 
    let startTime = 0, totalBonusTime = 0, currentDisplayTime = 30.00;
    let animationId; 
    let currentDiff = 'normal';
    let isInvincible = false, invincibleTimer = null; 
    let currentPlayerName = "STUDENT";
    
    // Equation tracking
    let completedFormulas = []; // Stores index of completed formulas
    let currentInput = []; // Symbols caught for current sequence

    // Difficulty settings [Target%, Valid%, Trap%, Clock%, Star%]
    const diffSettings = {
        'easy': { name: '0', speedBase: 0.003, rates: [0.50, 0.47, 0.00, 0.03, 0.00], starTime: 0 },
        'normal': { name: '9.81', speedBase: 0.005, rates: [0.40, 0.57, 0.00, 0.03, 0.00], starTime: 0 },
        'hard': { name: '19.62', speedBase: 0.007, rates: [0.35, 0.45, 0.18, 0.01, 0.01], starTime: 5000 },
        'very_hard': { name: '29.43', speedBase: 0.009, rates: [0.30, 0.40, 0.28, 0.01, 0.01], starTime: 3000 }
    };

    // Controls
    const keys = { ArrowLeft: false, ArrowRight: false };
    window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.code)) { keys[e.code] = true; e.preventDefault(); } });
    window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });
    const btnLeft = document.getElementById('btnLeft'); const btnRight = document.getElementById('btnRight');
    const pressLeft = (e) => { e.preventDefault(); keys.ArrowLeft = true; }; const releaseLeft = (e) => { e.preventDefault(); keys.ArrowLeft = false; };
    const pressRight = (e) => { e.preventDefault(); keys.ArrowRight = true; }; const releaseRight = (e) => { e.preventDefault(); keys.ArrowRight = false; };
    btnLeft.addEventListener('touchstart', pressLeft, {passive: false}); btnLeft.addEventListener('touchend', releaseLeft); btnLeft.addEventListener('mousedown', pressLeft); btnLeft.addEventListener('mouseup', releaseLeft); btnLeft.addEventListener('mouseleave', releaseLeft);
    btnRight.addEventListener('touchstart', pressRight, {passive: false}); btnRight.addEventListener('touchend', releaseRight); btnRight.addEventListener('mousedown', pressRight); btnRight.addEventListener('mouseup', releaseRight); btnRight.addEventListener('mouseleave', releaseRight);

    // üçé Player Object updated to Apple
    let player = { emoji: 'üçé', x: canvas.width / 2 };
    let fallingObjects = [];

    // Audio
    const AudioContext = window.AudioContext || window.webkitAudioContext; let audioCtx;
    function playSound(type) {
        if (!audioCtx) return; const osc = audioCtx.createOscillator(); const gainNode = audioCtx.createGain(); osc.connect(gainNode); gainNode.connect(audioCtx.destination);
        if(type === 'catch') { osc.type = 'sine'; osc.frequency.setValueAtTime(800, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1); gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); osc.start(); osc.stop(audioCtx.currentTime + 0.1); }
        else if(type === 'error') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2); gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2); osc.start(); osc.stop(audioCtx.currentTime + 0.2); }
        else if(type === 'success') { osc.type = 'square'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1); osc.frequency.linearRampToValueAtTime(1000, audioCtx.currentTime + 0.3); gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4); osc.start(); osc.stop(audioCtx.currentTime + 0.4); }
    }

    // Leaderboard logic
    async function renderLeaderboard() {
        try {
            // Order by compositeScore descending
            const q = query(collection(db, "physics_leaderboard"), orderBy("compositeScore", "desc"), limit(5));
            const querySnapshot = await getDocs(q);
            scoreList.innerHTML = '';
            if (querySnapshot.empty) { scoreList.innerHTML = '<li>Êö´ÁÑ°Á¥ÄÈåÑÔºåÊàêÁÇ∫È¶ñ‰ΩçÂ≠∏Èú∏Âï¶ÔºÅ</li>'; return; }
            querySnapshot.forEach((doc) => {
                const s = doc.data();
                const li = document.createElement('li');
                let resultText = s.completed === 4 ? `ÂÆåÊàê 4 Ê¢ù (ËÄóÊôÇ ${s.timeUsed}s)` : `ÂÆåÊàê ${s.completed} Ê¢ù`;
                li.innerHTML = `<span class="name-badge">${s.name}</span>${resultText} <span class="diff-badge">Èõ£Â∫¶ ${s.difficulty}</span>`;
                scoreList.appendChild(li);
            });
        } catch (error) { console.error("Error reading leaderboard:", error); scoreList.innerHTML = '<li>ËÆÄÂèñÂ§±Êïó</li>'; }
    }
    renderLeaderboard();

    async function saveScoreToCloud(completed, timeUsed, diffName, pName) {
        try {
            // Composite score: heavily weight completed count, then time (faster is higher score)
            let timeMs = Math.floor(parseFloat(timeUsed) * 100);
            let compositeScore = (completed * 100000);
            if (completed === 4) compositeScore += (100000 - timeMs); 

            await addDoc(collection(db, "physics_leaderboard"), { 
                name: pName, completed: completed, timeUsed: timeUsed, 
                compositeScore: compositeScore, difficulty: diffName, timestamp: new Date() 
            });
        } catch (error) { console.error("Error saving score:", error); }
    }

    // Logic: Get valid next symbols based on current input
    function getValidTargets() {
        if (currentInput.length === 0) {
            let valid = new Set();
            formulas.forEach((f, i) => { if (!completedFormulas.includes(i)) valid.add(f[0]); });
            return Array.from(valid);
        }
        let valid = new Set();
        formulas.forEach((f, i) => {
            if (completedFormulas.includes(i)) return;
            let match = true;
            for (let j=0; j<currentInput.length; j++) { if (f[j] !== currentInput[j]) { match = false; break; } }
            if (match && f.length > currentInput.length) valid.add(f[currentInput.length]);
        });
        return Array.from(valid);
    }

    function spawnObject() {
        if (!isPlaying) return;
        
        const settings = diffSettings[currentDiff];
        const r = Math.random();
        let symbol = '';
        let type = 'symbol'; 
        
        let targetProb = settings.rates[0];
        let validProb = settings.rates[1];
        let trapProb = settings.rates[2];
        let clockProb = settings.rates[3];
        
        let validTargets = getValidTargets();

        if (r < clockProb) { symbol = '‚è∞'; type = 'clock'; }
        else if (r < clockProb + settings.rates[4]) { symbol = '‚≠ê'; type = 'star'; }
        else if (r < clockProb + settings.rates[4] + trapProb) {
            symbol = trapSymbols[Math.floor(Math.random() * trapSymbols.length)];
            type = 'trap';
        }
        else if (r < clockProb + settings.rates[4] + trapProb + targetProb && validTargets.length > 0) {
            symbol = validTargets[Math.floor(Math.random() * validTargets.length)];
        }
        else {
            symbol = allValidSymbols[Math.floor(Math.random() * allValidSymbols.length)];
        }

        let objSize = Math.max(30, Math.min(60, canvas.width * 0.08));
        let speed = canvas.height * settings.speedBase * (0.8 + Math.random() * 0.4);

        fallingObjects.push({
            symbol: symbol, type: type,
            x: objSize + Math.random() * (canvas.width - objSize * 2),
            y: -objSize, size: objSize, speed: speed
        });
    }

    function activateStar() { 
        playSound('success'); isInvincible = true; 
        powerUpMsg.innerText = "‚≠ê‚≠ê ÂÖ¨ÂºèË≠∑Áõæ ‚≠ê‚≠ê"; powerUpMsg.style.opacity = "1"; 
        if (invincibleTimer) clearTimeout(invincibleTimer); 
        invincibleTimer = setTimeout(() => { isInvincible = false; powerUpMsg.style.opacity = "0"; }, diffSettings[currentDiff].starTime); 
    }
    
    function activateClock() { 
        playSound('success'); totalBonusTime += 3; 
        powerUpMsg.innerText = "‚è∞ ÊôÇÈñì +3 Áßí ‚è∞"; powerUpMsg.style.opacity = "1"; 
        setTimeout(() => { if(!isInvincible) powerUpMsg.style.opacity = "0"; }, 1500); 
    }

    function drawBlock(obj) {
        ctx.font = `bold ${obj.size * 0.7}px Arial`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        
        if (obj.type === 'clock' || obj.type === 'star' || obj.symbol === 'üçé' || obj.symbol === 'üéâ' || obj.symbol === 'üíØ') {
            ctx.fillText(obj.symbol, obj.x, obj.y);
            return;
        }

        let bgColor = '#ecf0f1'; let textColor = '#2c3e50';
        if (obj.type === 'trap') { bgColor = '#e74c3c'; textColor = 'white'; }
        
        ctx.fillStyle = bgColor;
        ctx.beginPath(); ctx.roundRect(obj.x - obj.size/2, obj.y - obj.size/2, obj.size, obj.size, 8); ctx.fill();
        ctx.fillStyle = textColor;
        ctx.fillText(obj.symbol, obj.x, obj.y);
    }

    function updateEquationDisplay() {
        if (currentInput.length === 0) equationDisplay.innerText = "Ë´ãÊé•ÂèñÂÖ¨ÂºèËµ∑ÂßãÁ¨¶Ëôü...";
        else equationDisplay.innerText = currentInput.join(" ") + " _";
    }

    function update() {
        if (!isPlaying) return; ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let now = Date.now();
        let elapsed = (now - startTime) / 1000;
        currentDisplayTime = Math.max(0, 30.00 + totalBonusTime - elapsed);
        timeDisplay.innerText = `ÊôÇÈñì: ${currentDisplayTime.toFixed(2)}s`;

        if (currentDisplayTime <= 0) { endGame(); return; }

        player.size = Math.max(50, Math.min(100, canvas.width * 0.12));
        player.y = canvas.height - player.size;
        let pSpeed = canvas.width * 0.015;

        if (keys.ArrowLeft && player.x > player.size / 2) player.x -= pSpeed; 
        if (keys.ArrowRight && player.x < canvas.width - player.size / 2) player.x += pSpeed;
        
        if (isInvincible) { ctx.shadowColor = "#f1c40f"; ctx.shadowBlur = 30; } else { ctx.shadowBlur = 0; }
        drawBlock({symbol: player.emoji, x: player.x, y: player.y, size: player.size}); ctx.shadowBlur = 0; 

        let validTargets = getValidTargets();

        for (let i = fallingObjects.length - 1; i >= 0; i--) {
            let obj = fallingObjects[i]; obj.y += obj.speed;
            if (obj.type === 'star' || obj.type === 'clock') { ctx.shadowColor = "white"; ctx.shadowBlur = 15; }
            drawBlock(obj); ctx.shadowBlur = 0;

            const dx = player.x - obj.x; const dy = player.y - obj.y;
            if (Math.sqrt(dx * dx + dy * dy) < (player.size/2 + obj.size/2 - 10)) { 
                
                if (obj.type === 'star') activateStar(); 
                else if (obj.type === 'clock') activateClock(); 
                else {
                    if (validTargets.includes(obj.symbol)) {
                        playSound('catch');
                        currentInput.push(obj.symbol);
                        
                        formulas.forEach((f, idx) => {
                            if (!completedFormulas.includes(idx) && currentInput.join('') === f.join('')) {
                                completedFormulas.push(idx);
                                currentInput = []; 
                                scoreDisplay.innerText = `ÂÆåÊàê: ${completedFormulas.length}/4`;
                                playSound('success');
                                fallingObjects.push({symbol: 'üíØ', type: 'reward', x: player.x, y: player.y - 50, size: 80, speed: -2});
                            }
                        });

                        updateEquationDisplay();
                        
                        if (completedFormulas.length === 4) { endGame(true); return; } 
                    } else {
                        if (!isInvincible) {
                            playSound('error');
                            currentInput = []; 
                            updateEquationDisplay();
                            equationDisplay.style.color = '#e74c3c';
                            setTimeout(()=> equationDisplay.style.color = '#f1c40f', 300);
                        }
                    }
                }
                fallingObjects.splice(i, 1); continue;
            }
            if (obj.y > canvas.height + obj.size || obj.y < -100) fallingObjects.splice(i, 1); 
        }
        
        let spawnRate = 0.04; if (currentDiff === 'hard') spawnRate = 0.06; if (currentDiff === 'very_hard') spawnRate = 0.08; 
        if (Math.random() < spawnRate) spawnObject();
        
        animationId = requestAnimationFrame(update);
    }

    function startGame() {
        currentPlayerName = playerNameInput.value.trim().toUpperCase() || "STUDENT";
        for(let radio of difficultyRadios) { if(radio.checked) currentDiff = radio.value; }

        completedFormulas = []; currentInput = []; fallingObjects = []; 
        totalBonusTime = 0; startTime = Date.now(); currentDisplayTime = 30.00;
        player.x = canvas.width / 2; isPlaying = true; isInvincible = false; powerUpMsg.style.opacity = "0";
        if(invincibleTimer) clearTimeout(invincibleTimer);
        
        scoreDisplay.innerText = `ÂÆåÊàê: 0/4`; updateEquationDisplay();
        overlay.classList.add('hidden'); 

        if (!audioCtx) audioCtx = new AudioContext(); if (audioCtx.state === 'suspended') audioCtx.resume();
        resizeCanvas();
        update();
    }

    async function endGame(allCompleted = false) {
        isPlaying = false; cancelAnimationFrame(animationId);
        
        startBtn.innerText = "‰∏äÂÇ≥ÊàêÁ∏æ‰∏≠..."; startBtn.disabled = true;

        let finalTimeUsed = allCompleted ? (30.00 + totalBonusTime - currentDisplayTime).toFixed(2) : "30.00";
        
        await saveScoreToCloud(completedFormulas.length, finalTimeUsed, diffSettings[currentDiff].name, currentPlayerName);
        await renderLeaderboard();

        gameOverTitle.innerHTML = allCompleted ? "üèÜ Â≠∏Èú∏Ë™ïÁîüÔºÅüèÜ" : "ÊôÇÈôêÂà∞ÔºÅÂÜçÊé•ÂÜçÂé≤";
        finalScore.innerText = allCompleted ? `ÂÖ®ÈÉ®ÂÆåÊàêÔºÅËÄóÊôÇÔºö${finalTimeUsed} Áßí` : `ÊàêÂäüÂÆåÊàêÔºö${completedFormulas.length} Ê¢ùÂÖ¨Âºè`;
        finalScore.classList.remove('hidden');
        
        startBtn.innerText = "ÂÜçÊ¨°ÊåëÊà∞"; startBtn.disabled = false;
        document.getElementById('difficultyUI').classList.remove('hidden');
        powerUpMsg.style.opacity = "0"; 
        
        keys.ArrowLeft = false; keys.ArrowRight = false; overlay.classList.remove('hidden');
    }

    startBtn.addEventListener('click', startGame);
</script>
</body>
</html>